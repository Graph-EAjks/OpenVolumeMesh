/**

\page concepts Concepts of OpenVolumeMesh

\section halfedges From Half-Edges to Half-Faces

The concepts of %OpenVolumeMesh are closely related to those of %OpenMesh (http://www.openmesh.org).
For further reading on the concepts of %OpenMesh, refer to \cite Botsch02OpenMesh.
%OpenMesh is used to handle two-manifold geometric meshes. For this purpose, it distinguishes
between \e vertices, \e edges, and \e faces. The main idea in %OpenMesh is to represent the
edges as a pair of so-called half-edges that have opposing orientations. Additional local adjacency
information is stored for each half-edge such that the navigation on the mesh can be completely
accomplished by using only this local links to adjacent structures (similar to e.g. a linked list).
This, of course, assumes the surface mesh to be two-manifold.
 
The main concept of %OpenVolumeMesh is slightly different but shares some of its ideas with
%OpenMesh. In order to represent volumetric meshes (three-manifolds),
%OpenVolumeMesh extends the set of entities by \e cells.
In %OpenVolumeMesh, all entities are stored in arrays (STL vectors) rather than
in adjacency linked lists. This has the major advantage that the data structure allows
for configurations that are not three-manifold (since this is desired in some applications).
For example, a set of vertices or just a two-manifold surface can be respresented by
%OpenVolumeMesh as well as an entirely three-manifold tetrahedral mesh.
In order to offer the possibility to locally navigate on the meshes, we carry over
the idea of splitting edges into half-edges to the faces. This leads to the separation
of the faces into a pair of so-called half-faces. Each of the half-faces has opposite
orientation to its counter-part. The orientation of a half-face is uniquely determined
by its incident half-edges. See Figure 1 for an illustration of this concept.

\image html halfedge_halfface.png "Figure 1. Left: Two half-edges as in OpenMesh. Right: A face split into two half-faces."

\section adjacencies Adjacency Relations

The entities in %OpenVolumeMesh are arranged hierarchically and we distinguish between
two adjacency relations:

\li The (intrinsic) top-down adjacencies and
\li the bottom-up adjacencies.

\subsection top_down The Top-Down Adjacency Relation

Each entity of dimension n is defined as a tuple of entities of dimension n-1,
except for the vertices. So, edges are defined as a pair of vertices, (half-)faces are defined as
a j-tuple of (half-)edges, where j is the valence of the face, and cells are defined
as a k-tuple of (half-)faces, where k is the valence of the cell. This adjacency
relation is intrinsically given by definition. %OpenVolumeMesh can use these
adjacencies in order to provide \e top-down circulators, that is circulators
that address all adjacent lower-dimensional entities of a given reference entity.
Read more on iterators and circulators in Section \ref iterators_and_circulators. 
Figure 2 illustrates this hierarchy.

\image html volume_mesh_hierarchy.png "Figure 2. Each entity is defined as a tuple of lower-dimensional entities."

\subsection bottom_up The Bottom-Up Adjacency Relation

In many cases, the adjacency list to higher dimensional entities for a given entity is
required. Therefore, %OpenVolumeMesh offers the opportunity to explicitly compute
the so-called \e bottom-up adjacencies. For this, %OpenVolumeMesh stores the
following information for the respective entity type in additional caches:

\li \b Vertex: A list of all outgoing half-edges.
\li \b Half-Edge: An (ordered) list of all incident half-faces.
\li \b Half-Face: The handle to an incident cell or none if it is a boundary half-face.

The computation of this adjacency relations is performed in linear time complexity.
Call function OpenVolumeMesh::PolyhedralMesh::update_adjacencies() after the
topology of the mesh is completely initialized. Note that each time the topology
of the mesh has changed, the bottom-up adjacencies have to be updated.
Note also that most of the iterators and circulators rely on these adjacency lists,
so, many of them do not work unless OpenVolumeMesh::PolyhedralMesh::update_adjacencies()
is called.

\section genericity Genericity

\subsection generic_embedding Generic Embedding

The %OpenVolumeMesh library is designed to be as generic as possible. So, at one hand,
the developer can choose the vector space into which a mesh is embedded. For example,
most instances require their vertices being elements of \f$\mathbb{R}^3\f$.
But in some cases, one might want e.g. two-dimensional integer coordinates,
so elements in \f$\mathbb{N}_0^2\f$. In %OpenVolumeMesh, the embedded vector
type can be specified as template parameter. The libraray is shipped with a vector
class that also specifies all necessary operations on vectors (such as dot- and cross-product,
several norms, etc.). The most common vector types are predefined in VectorT.hh.
So, let's say we want to create a polyhedral mesh whose vertices are elements of
\f$\mathbb{N}_0^2\f$. We use the following code:

\code
#include <OpenVolumeMesh/Geometry/VectorT.hh>
#include <OpenVolumeMesh/PolyhedralMesh/PolyhedralMesh.hh>

void SomeClass::someFunction() {

  ...

  // Our two-dimensional integer vector class
  typedef OpenVolumeMesh::Geometry::Vec2ui Vec2ui;

  // Vec2ui stands for "two-dimensional vector of unsigned integers"

  // Our mesh using Vec2ui as vector type
  OpenVolumeMesh::PolyhedralMesh< Vec2ui > myMesh;

  ...

}
\endcode

\subsection generic_properties Generic Properties

Similar to the %OpenMesh data structure, it is possible to attach multiple properties
to any of the entities in %OpenVolumeMesh. The underlying property container class makes
use of C++ template programming concepts in order to allow the encapsulated property data
to be of any data type. Let's assume, we want to attach a label to the vertices and
some real valued weight to the edges of a mesh. Consider the following code:

\code
#include <string>

#include <OpenVolumeMesh/Geometry/VectorT.hh>
#include <OpenVolumeMesh/PolyhedralMesh/PolyhedralMesh.hh>

void SomeClass::someFunction {

  ...

  // Create mesh
  typedef OpenVolumeMesh::Geometry::Vec3d Vec3d;
  OpenVolumeMesh::PolyhedralMesh< Vec3d > myMesh;

  // Fill mesh
  ...

  // Attach label property (data type std::string) to the mesh
  OpenVolumeMesh::VPropHandleT< std::string > label;
  myMesh.add_property(label, "LabelProperty");

  // Fill property values
  for(OpenVolumeMesh::PolyhedralMesh< Vec3d >::VertexIter v_it = myMesh.vertices_begin();
        v_it != myMesh.vertices_end(); ++v_it) {

    // Assign same label to each vertex
    myMesh.property(label, *v_it) = "My Label";
  }
  
  // Now, attach weight property (data type float) to the mesh
  OpenVolumeMesh::EPropHandleT< float > weight;
  myMesh.add_property(weight, "EdgeWeightProperty");

  // Fill property values
  for(OpenVolumeMesh::PolyhedralMesh< Vec3d >::EdgeIter e_it = myMesh.edges_begin();
        e_it != myMesh.edges_end(); ++e_it) {

    // Assign same weight to each edge
    myMesh.property(weight, *e_it) = 3.14f;
  }

  // Finally, remove properties from the mesh
  myMesh.remove_property(label);
  myMesh.remove_property(weight);

  ...
}
\endcode

This, of course, also works for all half-entities (half-edges and half-faces).

**/
